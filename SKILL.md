
1 编辑方式。
一个技能可能会带来多个不同的效果，比如造成伤害的同时减伤，所以skii应该包含多个skillItem 
每个skillItem施法对象可能也不同，所以target应该编辑到skillItem上。 
target包含：自己、我方全体、敌方全体、敌方随机等 
另外skillItem的释放可能会受到一些条件的限制，比如第n回合才可以释放，或者该技能只对某个id的对象有效。所以可以编辑check 字段。 
 
每个skillItem对应的特效是个有序的动画列表。为了方便策划调整动画，每个动画prefab的间隔帧数、以及旋转方式不再编辑器里编辑。直接在引擎里面，通过在特效prefab上挂脚本的方式调整技能组合。 
技能带来的数值效果编辑在effect里面：这里分为两类:1 直接改变属性（加减防攻，加减血等）。2加buff，buff是有时效性的。在回合制游戏中就是第n回合后消除。 
 
所以一个技能的编辑方式总结如下 
Skill = [SkillItem] 
SkillItem  = { 
    target: 技能释放对象 
    check：条件检测 
    visuals：ui特效,是个数组，元素为特效路径 
    effect: 技能带来数值效果 
} 
 
2 实现方式 
 
先说下buff 
比如，A攻击B，给B加一个buff：每回合掉20点血，持续3回合。 
上面的技能在释放后，就销毁了，但是技能buff还在。buff和技能是两个系统 
buff是被动触发的，所以需要trigger（一个触发条件） 
比如上面buff 的触发条件就是每回合结束触发 
所以我们可以把buff触发条件编辑的trigger，初始化buff的时候注册对应事件（观察者模式） 
buff触发后，会释放一个SkillItem.复用了技能的SkillItem 
 
 
-技能系统会涉及到伪随机，以及最后的战斗校验。要逻辑与UI分离 
    技能如果依赖ui，伪随机种子使用的顺序可能会混乱。 
    举例： 
    释放技能对A和B造成随机伤害。如果UI上B的距离更近，则技能伤害结算顺序为 先B后A。虽然客户端这样搞也没问题，但是，如果有服务器验证。服务器是对伤害的结算是先A后B，所以前后端不一致。 
解决方法就是UI分离 
客户端技能释放完毕，不管UI，同帧出伤害结算。同时向外抛出一个VisualResult的对象。该对象只作用于UI，里面的数据是本次技能计算数据，包括暴击、加减攻防等。 
当然VisualResult并不是抛出后立刻处理，它会进入一个队列，只有上个VisualResult结束后，才会进行下一个。 
 
这里再说下技能特效 
技能特效一般是一系列特效的组合,每一个特效prefab上会挂一个SkillVisualSegment的脚本。里面处理特效的时长、旋转、缩放等，同时还会向外抛出事件。告诉技能效果队列处理下个技能
-----------------

