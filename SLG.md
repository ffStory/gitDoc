一个SLG项目的开发，从业务逻辑角度来说考虑一下几个方面  

一、递归post的事件系统  
二、cost条件消耗系统  
三、yield奖励系统  
四、和时间相关的buff系统  
五、task slot条系统  

做好以上，以后无论是新功能扩展还是维护，都会便捷很多

--------------------------
一、递归的post事件系统
事件是其他很多系统的基石，可以有效的解耦代码。
游戏中任何对象任何属性修改都是需要抛出事件的（游戏属性是数据库存储，有些属性是计算所得）。

我们拿招募100个id=1的士兵来举例说明：
招募士兵会改变Troop.number属性
post(Troop-number-1, 100)
会连续post以下几个事件
Troop-number-1     // id == 1的士兵数量改变
Troop-number        //士兵数量改变
Troop                     //这一级的事件基本没什么用

这样有什么好处？
以任务系统举例
现在有两个任务
任务A: 招募100个士兵。  //监听的事件为 Troop-number
任务B: id=1的士兵招募100个。  //监听的事件Troop-number-1
这样只需要post一个事件 Troop-number-1 这两个任务都会触发监听。

二、cost条件消耗
游戏中少不了条件判断和消耗配置。我们不能把策划数据写的杂乱无章更不能写死。
需求：以建筑升级为例
升级A建筑需要以下条件
1：消耗城市粮食100
2：消耗玩家体力100
3：C建筑到达5级
4：需要一个空闲Task 时间大于5分钟 //Task再后面介绍

设计：
我们把以上所有条件抽象成一个Cost。以上每个条件抽象为CostItem.  则 Cost = [CostItem]
我们设置CostItem的结构

消耗类型（consume），这类条件会消耗玩家资源，比如粮食、金币、体力等
则上面1、2可定义以下结构
consume  City.food  100  =>  [c, c-food, 100]
consume Player.energy 100 => [c, p-energy, 100]

则消耗类型结构定义为  【c, obj-attr, value】

条件类型（between），这类条件要求某个属性满足一个条件不等式

上面3定义以下结构
between  Building-C  5 => [b b-c, 5]
当然还有小于以及 在某个区间的条件判断。
暂不考虑Task则上面的条件可以用以下结构表示
Cost = [
    [c, c-food, 100],
    [c, p-energy, 100],
    [b, B-c, 5]
]

所t以策划配置表只要能导出以上结构，那么这个A建筑的升级条件就很简洁的表述完成。
在游戏中任何需要条件表示的地方，我们都可以配置成cost结构。可扩展极强。

除此之外，和事件系统结合我们会打造出一个Cost的监听系统。这在游戏开发中是刚需
比如：我们需要各种提示：活动开始、任务完成、建筑可升级。再比如我们完成了一个操作，而这个操作触发了另一个操作。
CostHandler.为此而设计
举例。A任务的完成条件是建筑B升级到5级。
首先策划会编辑任务的完成条件 
Cost = [
    [b, B-B, 5]
]

我们只需要监听这个Cost就行了。CostHandler以Cost作为参数。监听CostItem的变化，在这里是监听建筑B等级的变化。
就这样CostHandler 讲两个完全不同的系统，通过事件和条件结合起来。这为跨模块开发带来了很大便捷。


三、Yield系统
即奖励系统，游戏中所有可以获得的东西包括属性和物品 都可以通过这个系统编辑
例子：
升级建筑会获得以下奖励
1、玩家获得500 银币
2、玩家获得id=1的物品5个

抽象成
player-silver 500 => [p-silver, 500]
item-1 5 => [i-1, 5]

则整个奖励可编辑
Yiled = [
    [p-silver, 500]
    [i-1, 5]
]

有些时候奖励也是需要概率随机的，也可以在这里配置

四、buff系统
待更。。。

五、Task系统
代更。。。

